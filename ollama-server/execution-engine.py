#!/usr/bin/env python3
"""
Financial Analysis Execution Engine

This service executes tool call plans generated by the ollama-server.
It orchestrates calls to MCP servers and returns structured financial data.
"""

import asyncio
import json
import logging
import traceback
from datetime import datetime
from typing import Dict, Any, List, Optional, Union
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import uvicorn
import httpx

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("execution-engine")

app = FastAPI(title="Financial Analysis Execution Engine")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class ToolCall(BaseModel):
    fn: str
    args: Dict[str, Any]

class ExecutionPlan(BaseModel):
    steps: List[ToolCall]

class ExecutionRequest(BaseModel):
    question: str
    plan: ExecutionPlan
    description: Optional[str] = None

class ExecutionResponse(BaseModel):
    success: bool
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    timestamp: str

class FinancialExecutionEngine:
    def __init__(self):
        self.mcp_servers = {
            "mcp-financial-server": "http://localhost:8001",
            "mcp-analytics-server": "http://localhost:8002"
        }
        self.tool_server_mapping = {}
        self.execution_results = {}
        
    async def initialize(self):
        """Initialize the execution engine by discovering tool mappings"""
        logger.info("Initializing execution engine...")
        
        # Discover available tools from MCP servers
        for server_name, server_url in self.mcp_servers.items():
            try:
                async with httpx.AsyncClient(timeout=10.0) as client:
                    response = await client.get(f"{server_url}/tools")
                    if response.status_code == 200:
                        tools_data = response.json()
                        if "tools" in tools_data:
                            for tool in tools_data["tools"]:
                                tool_name = tool.get("name")
                                if tool_name:
                                    self.tool_server_mapping[tool_name] = server_name
                        logger.info(f"Mapped {len(tools_data.get('tools', []))} tools from {server_name}")
                    else:
                        logger.warning(f"Failed to get tools from {server_name}: {response.status_code}")
            except Exception as e:
                logger.error(f"Failed to connect to {server_name}: {e}")
        
        logger.info(f"Tool mapping complete. {len(self.tool_server_mapping)} tools available.")
        
    def get_server_for_tool(self, tool_name: str) -> Optional[str]:
        """Get the server name that hosts a specific tool"""
        return self.tool_server_mapping.get(tool_name)
    
    def get_server_url(self, server_name: str) -> Optional[str]:
        """Get the URL for a server"""
        return self.mcp_servers.get(server_name)
    
    async def execute_tool_call(self, tool_call: ToolCall) -> Dict[str, Any]:
        """Execute a single tool call via MCP server"""
        tool_name = tool_call.fn
        tool_args = tool_call.args
        
        # Find which server hosts this tool
        server_name = self.get_server_for_tool(tool_name)
        if not server_name:
            return {
                "success": False,
                "error": f"Unknown tool: {tool_name}",
                "tool": tool_name,
                "args": tool_args
            }
        
        server_url = self.get_server_url(server_name)
        if not server_url:
            return {
                "success": False,
                "error": f"Server not available: {server_name}",
                "tool": tool_name,
                "args": tool_args
            }
        
        try:
            # Execute tool call via MCP server HTTP wrapper
            async with httpx.AsyncClient(timeout=30.0) as client:
                # For now, we'll use a simple POST to execute tools
                # This assumes the MCP wrapper has execution endpoints
                response = await client.post(
                    f"{server_url}/execute/{tool_name}",
                    json=tool_args
                )
                
                if response.status_code == 200:
                    result = response.json()
                    return {
                        "success": True,
                        "tool": tool_name,
                        "args": tool_args,
                        "result": result,
                        "server": server_name
                    }
                else:
                    return {
                        "success": False,
                        "error": f"Tool execution failed: {response.status_code} - {response.text}",
                        "tool": tool_name,
                        "args": tool_args,
                        "server": server_name
                    }
                    
        except Exception as e:
            logger.error(f"Error executing tool {tool_name}: {e}")
            return {
                "success": False,
                "error": f"Execution error: {str(e)}",
                "tool": tool_name,
                "args": tool_args,
                "server": server_name
            }
    
    async def execute_plan(self, execution_request: ExecutionRequest) -> Dict[str, Any]:
        """Execute a complete tool call plan"""
        question = execution_request.question
        plan = execution_request.plan
        description = execution_request.description or f"Execution plan for: {question}"
        
        logger.info(f"Executing plan with {len(plan.steps)} steps for question: {question}")
        
        # Execute all tool calls
        execution_results = []
        successful_calls = 0
        failed_calls = 0
        
        for i, tool_call in enumerate(plan.steps):
            logger.info(f"Executing step {i+1}/{len(plan.steps)}: {tool_call.fn}")
            
            result = await self.execute_tool_call(tool_call)
            execution_results.append(result)
            
            if result["success"]:
                successful_calls += 1
                logger.info(f"✅ Step {i+1} completed: {tool_call.fn}")
            else:
                failed_calls += 1
                logger.error(f"❌ Step {i+1} failed: {tool_call.fn} - {result['error']}")
        
        # Format results for QnA frontend
        formatted_results = await self.format_execution_results(
            question, 
            description,
            execution_results, 
            successful_calls, 
            failed_calls
        )
        
        return formatted_results
    
    async def format_execution_results(
        self, 
        question: str,
        description: str,
        execution_results: List[Dict[str, Any]], 
        successful_calls: int, 
        failed_calls: int
    ) -> Dict[str, Any]:
        """Format execution results into QnA-compatible JSON structure"""
        
        # Create body array with execution details
        body = [
            {
                "key": "question",
                "value": question,
                "description": "The financial question that was executed"
            },
            {
                "key": "execution_summary",
                "value": f"{successful_calls} successful, {failed_calls} failed",
                "description": "Summary of tool call execution results"
            }
        ]
        
        # Add results from successful tool calls
        for i, result in enumerate(execution_results):
            if result["success"]:
                # Extract meaningful data from the result
                tool_data = result.get("result", {})
                body.append({
                    "key": f"step_{i+1}_{result['tool']}",
                    "value": tool_data,
                    "description": f"Results from {result['tool']} executed on {result['server']}"
                })
            else:
                # Include error information
                body.append({
                    "key": f"step_{i+1}_{result['tool']}_error",
                    "value": result["error"],
                    "description": f"Error executing {result['tool']} on {result['server']}"
                })
        
        # Add aggregated insights if we have successful results
        if successful_calls > 0:
            insights = await self.generate_insights(execution_results)
            if insights:
                body.extend(insights)
        
        return {
            "success": True,
            "data": {
                "description": description,
                "body": body,
                "metadata": {
                    "timestamp": datetime.now().isoformat(),
                    "execution_summary": {
                        "total_steps": len(execution_results),
                        "successful_steps": successful_calls,
                        "failed_steps": failed_calls,
                        "success_rate": f"{(successful_calls/len(execution_results)*100):.1f}%" if execution_results else "0%"
                    },
                    "data_sources": list(set([r.get("server", "unknown") for r in execution_results if r["success"]])),
                    "calculation_methods": ["mcp_tool_execution"],
                    "execution_mode": "live_data"
                }
            }
        }
    
    async def generate_insights(self, execution_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Generate aggregated insights from execution results"""
        insights = []
        
        # Example: if we have stock data, calculate some basic metrics
        # This is a placeholder for more sophisticated analysis
        successful_results = [r for r in execution_results if r["success"]]
        
        if successful_results:
            insights.append({
                "key": "data_freshness",
                "value": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "description": "Timestamp when this data was retrieved from live financial APIs"
            })
            
            # Add more insights based on the type of data retrieved
            tool_types = [r["tool"] for r in successful_results]
            if any("bars" in tool or "price" in tool for tool in tool_types):
                insights.append({
                    "key": "data_type",
                    "value": "Market Data",
                    "description": "This analysis includes real-time or recent market pricing data"
                })
        
        return insights

# Initialize the execution engine
execution_engine = FinancialExecutionEngine()

@app.on_event("startup")
async def startup_event():
    """Initialize the execution engine on startup"""
    await execution_engine.initialize()

@app.post("/execute", response_model=ExecutionResponse)
async def execute_plan(request: ExecutionRequest):
    """
    Execute a tool call plan and return structured financial data
    """
    try:
        logger.info(f"Received execution request for: {request.question}")
        
        # Execute the plan
        result = await execution_engine.execute_plan(request)
        
        return ExecutionResponse(
            success=result["success"],
            data=result.get("data"),
            error=result.get("error"),
            timestamp=datetime.now().isoformat()
        )
        
    except Exception as e:
        logger.error(f"Error in execute endpoint: {e}")
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy", 
        "timestamp": datetime.now().isoformat(),
        "available_tools": len(execution_engine.tool_server_mapping),
        "mcp_servers": list(execution_engine.mcp_servers.keys())
    }

@app.get("/tools")
async def list_available_tools():
    """List all available tools and their server mappings"""
    return {
        "tools": execution_engine.tool_server_mapping,
        "servers": execution_engine.mcp_servers,
        "total_tools": len(execution_engine.tool_server_mapping)
    }

if __name__ == "__main__":
    print("Starting Financial Analysis Execution Engine...")
    print("Server will be available at: http://localhost:8003")
    print("API Documentation at: http://localhost:8003/docs")
    print("\nTo execute a plan, send a POST request to /execute with:")
    print('{"question": "Your question", "plan": {"steps": [{"fn": "tool_name", "args": {...}}]}}')
    print("\nMake sure you have:")
    print("1. MCP HTTP wrappers running: ./start-mcp-wrappers.sh")
    print("2. Financial server wrapper: http://localhost:8001")
    print("3. Analytics server wrapper: http://localhost:8002")
    print("\nThis execution engine will:")
    print("- Execute tool call plans generated by ollama-server")
    print("- Orchestrate calls to multiple MCP servers")
    print("- Return structured JSON results for QnA frontend")
    print("- Handle errors gracefully with partial results")
    
    uvicorn.run(app, host="0.0.0.0", port=8003)