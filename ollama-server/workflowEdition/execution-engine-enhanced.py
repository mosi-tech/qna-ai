#!/usr/bin/env python3
"""
Enhanced Financial Analysis Execution Engine

This service executes tool call plans and Python fallback scripts generated by the ollama-server.
It orchestrates calls to MCP servers and executes custom Python analysis code.
"""

import asyncio
import json
import logging
import traceback
import tempfile
import subprocess
import sys
import os
from datetime import datetime
from typing import Dict, Any, List, Optional, Union
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import uvicorn
import httpx

# Add mcp-server to path for direct function imports
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'mcp-server'))

# Import functions directly from MCP servers
try:
    from financial.functions_mock import MOCK_FINANCIAL_FUNCTIONS
    from analytics.portfolio.metrics import calculate_portfolio_metrics
    from analytics.risk.metrics import calculate_var, calculate_cvar
    from analytics.indicators.technical import calculate_sma, calculate_rsi, calculate_macd
    print("✅ Successfully imported MCP functions directly")
except ImportError as e:
    print(f"❌ Failed to import MCP functions: {e}")
    MOCK_FINANCIAL_FUNCTIONS = {}

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("execution-engine")

app = FastAPI(title="Enhanced Financial Analysis Execution Engine")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class ToolCall(BaseModel):
    fn: str
    args: Dict[str, Any]
    output: Optional[str] = None  # Output variable name

class PythonFallback(BaseModel):
    data_needed: List[ToolCall]
    script: Optional[str] = None
    script_reference: Optional[str] = None
    function_name: Optional[str] = None

class ExecutionPlan(BaseModel):
    steps: Optional[List[ToolCall]] = None
    python_fallback: Optional[PythonFallback] = None

class ExecutionRequest(BaseModel):
    question: str
    plan: ExecutionPlan
    description: Optional[str] = None

class ExecutionResponse(BaseModel):
    success: bool
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    timestamp: str

class EnhancedFinancialExecutionEngine:
    def __init__(self):
        self.mcp_servers = {
            "mcp-financial-server": "http://localhost:8001",
            "mcp-analytics-server": "http://localhost:8002"
        }
        self.tool_server_mapping = {}
        self.execution_results = {}
        
        # Direct function mapping for bypass
        self.direct_functions = {}
        self._setup_direct_functions()
    
    def _setup_direct_functions(self):
        """Setup direct function mapping to bypass MCP HTTP calls"""
        # Add financial functions
        if MOCK_FINANCIAL_FUNCTIONS:
            for func_name, func in MOCK_FINANCIAL_FUNCTIONS.items():
                self.direct_functions[func_name] = func
                logger.info(f"Mapped direct function: {func_name}")
        
        # Add analytics functions (these would need to be expanded)
        # self.direct_functions["calculate_portfolio_metrics"] = calculate_portfolio_metrics
        # self.direct_functions["calculate_var"] = calculate_var
        # etc.
        
        logger.info(f"Direct function mapping complete. {len(self.direct_functions)} functions available.")
    
    async def initialize(self):
        """Initialize the execution engine by discovering tool mappings"""
        logger.info("Initializing enhanced execution engine...")
        
        # Discover available tools from MCP servers
        for server_name, server_url in self.mcp_servers.items():
            try:
                async with httpx.AsyncClient(timeout=10.0) as client:
                    response = await client.get(f"{server_url}/tools")
                    if response.status_code == 200:
                        tools_data = response.json()
                        if "tools" in tools_data:
                            for tool in tools_data["tools"]:
                                tool_name = tool.get("name")
                                if tool_name:
                                    self.tool_server_mapping[tool_name] = server_name
                        logger.info(f"Mapped {len(tools_data.get('tools', []))} tools from {server_name}")
                    else:
                        logger.warning(f"Failed to get tools from {server_name}: {response.status_code}")
            except Exception as e:
                logger.error(f"Failed to connect to {server_name}: {e}")
        
        logger.info(f"Tool mapping complete. {len(self.tool_server_mapping)} tools available.")
        
    async def execute_tool_call(self, tool_call: ToolCall) -> Dict[str, Any]:
        """Execute a single tool call - try direct functions first, then MCP servers"""
        tool_name = tool_call.fn
        tool_args = tool_call.args
        
        # Try direct function call first (bypass MCP HTTP)
        if tool_name in self.direct_functions:
            try:
                logger.info(f"Executing direct function: {tool_name}")
                result = self.direct_functions[tool_name](**tool_args)
                
                # Format result to match MCP response structure
                return {
                    "success": True,
                    "tool": tool_name,
                    "args": tool_args,
                    "result": {
                        "content": [{
                            "type": "text",
                            "text": json.dumps(result, indent=2, default=str)
                        }]
                    },
                    "server": "direct-import"
                }
            except Exception as e:
                logger.error(f"Direct function call failed for {tool_name}: {e}")
                return {
                    "success": False,
                    "error": f"Direct function execution error: {str(e)}",
                    "tool": tool_name,
                    "args": tool_args,
                    "server": "direct-import"
                }
        
        # Fall back to MCP HTTP calls
        server_name = self.tool_server_mapping.get(tool_name)
        if not server_name:
            return {
                "success": False,
                "error": f"Unknown tool: {tool_name} (not in direct functions or MCP mapping)",
                "tool": tool_name,
                "args": tool_args
            }
        
        server_url = self.mcp_servers.get(server_name)
        if not server_url:
            return {
                "success": False,
                "error": f"Server not available: {server_name}",
                "tool": tool_name,
                "args": tool_args
            }
        
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.post(
                    f"{server_url}/execute/{tool_name}",
                    json=tool_args
                )
                
                if response.status_code == 200:
                    result = response.json()
                    return {
                        "success": True,
                        "tool": tool_name,
                        "args": tool_args,
                        "result": result,
                        "server": server_name
                    }
                else:
                    return {
                        "success": False,
                        "error": f"Tool execution failed: {response.status_code} - {response.text}",
                        "tool": tool_name,
                        "args": tool_args,
                        "server": server_name
                    }
                    
        except Exception as e:
            logger.error(f"Error executing tool {tool_name}: {e}")
            return {
                "success": False,
                "error": f"Execution error: {str(e)}",
                "tool": tool_name,
                "args": tool_args,
                "server": server_name
            }

    async def execute_python_script(self, script: str, context_data: Dict[str, Any]) -> Dict[str, Any]:
        """Execute Python script directly in the same environment"""
        try:
            # Import required libraries directly
            import pandas as pd
            import numpy as np
            
            # Create execution namespace with context data and libraries
            namespace = {
                # Standard libraries
                'json': json,
                'datetime': datetime,
                'pd': pd,
                'np': np,
                # Context data
                'context_data': context_data,
                'position_symbols': context_data.get('position_symbols', []),
                'bars_data': context_data.get('bars_data', {}),
                # Built-ins
                '__builtins__': __builtins__
            }
            
            # Execute the script in the namespace
            exec(script, namespace)
            
            # The script should have set a 'result' variable or we'll return the namespace
            if 'result' in namespace:
                output_data = namespace['result']
            else:
                # Look for any variables that might be results
                output_data = {k: v for k, v in namespace.items() 
                             if not k.startswith('_') and k not in ['json', 'datetime', 'pd', 'np', 'context_data', 'position_symbols', 'bars_data']}
            
            return {
                "success": True,
                "result": output_data,
                "stdout": "",
                "stderr": ""
            }
                
        except Exception as e:
            logger.error(f"Error executing Python script: {e}")
            import traceback
            return {
                "success": False,
                "error": f"Script execution error: {str(e)}",
                "traceback": traceback.format_exc()
            }
    
    async def execute_plan(self, execution_request: ExecutionRequest) -> Dict[str, Any]:
        """Execute a complete tool call plan or Python fallback"""
        question = execution_request.question
        plan = execution_request.plan
        description = execution_request.description or f"Execution plan for: {question}"
        
        logger.info(f"Executing plan for question: {question}")
        
        if plan.steps:
            # Regular MCP tool execution
            return await self.execute_mcp_plan(question, description, plan.steps)
        elif plan.python_fallback:
            # Python fallback execution
            return await self.execute_python_fallback(question, description, plan.python_fallback)
        else:
            return {
                "success": False,
                "error": "No valid execution plan provided"
            }

    async def execute_mcp_plan(self, question: str, description: str, steps: List[ToolCall]) -> Dict[str, Any]:
        """Execute regular MCP tool plan"""
        execution_results = []
        successful_calls = 0
        failed_calls = 0
        
        for i, tool_call in enumerate(steps):
            logger.info(f"Executing step {i+1}/{len(steps)}: {tool_call.fn}")
            
            result = await self.execute_tool_call(tool_call)
            execution_results.append(result)
            
            if result["success"]:
                successful_calls += 1
                logger.info(f"✅ Step {i+1} completed: {tool_call.fn}")
            else:
                failed_calls += 1
                logger.error(f"❌ Step {i+1} failed: {tool_call.fn} - {result['error']}")
        
        return await self.format_execution_results(
            question, description, execution_results, successful_calls, failed_calls
        )

    async def execute_python_fallback(self, question: str, description: str, fallback: PythonFallback) -> Dict[str, Any]:
        """Execute Python fallback with data gathering"""
        logger.info(f"Executing Python fallback with {len(fallback.data_needed)} data gathering steps")
        
        # First, gather the needed data
        context_data = {}
        data_results = []
        
        for i, tool_call in enumerate(fallback.data_needed):
            logger.info(f"Gathering data step {i+1}/{len(fallback.data_needed)}: {tool_call.fn}")
            
            result = await self.execute_tool_call(tool_call)
            data_results.append(result)
            
            if result["success"]:
                # Store raw result for debugging
                tool_result_key = f"tool_result_{i}"
                context_data[tool_result_key] = result
                
                # Extract the actual data from MCP response and store with specified variable name
                if tool_call.output:
                    try:
                        # Extract actual data from MCP response structure (handle double nested result)
                        mcp_result = result.get("result", {})
                        
                        # Check for nested result structure (MCP HTTP wrapper pattern)
                        if "result" in mcp_result:
                            inner_result = mcp_result["result"]
                            if "content" in inner_result and len(inner_result["content"]) > 0:
                                # Parse the JSON string from the content
                                content_text = inner_result["content"][0].get("text", "")
                                actual_data = json.loads(content_text)
                                
                                # Store the actual data with the specified variable name
                                context_data[tool_call.output] = actual_data
                                
                                # For positions, also extract symbols for convenience
                                if "positions" in tool_call.fn and isinstance(actual_data, list):
                                    context_data["position_symbols"] = [p.get("symbol") for p in actual_data if p.get("symbol")]
                                
                                logger.info(f"Successfully extracted {tool_call.output}: {type(actual_data)}")
                            else:
                                context_data[tool_call.output] = None
                                logger.warning(f"No content found in inner result for {tool_call.output}")
                        
                        # Fallback: try direct content access for simpler MCP responses
                        elif "content" in mcp_result and len(mcp_result["content"]) > 0:
                            content_text = mcp_result["content"][0].get("text", "")
                            actual_data = json.loads(content_text)
                            context_data[tool_call.output] = actual_data
                            
                            if "positions" in tool_call.fn and isinstance(actual_data, list):
                                context_data["position_symbols"] = [p.get("symbol") for p in actual_data if p.get("symbol")]
                                
                            logger.info(f"Successfully extracted {tool_call.output} (direct): {type(actual_data)}")
                        else:
                            context_data[tool_call.output] = None
                            logger.warning(f"No content structure found for {tool_call.output}")
                            
                    except Exception as e:
                        logger.error(f"Failed to extract data for {tool_call.output}: {e}")
                        context_data[tool_call.output] = None
        
        # Execute the Python analysis script
        logger.info("Executing Python analysis script...")
        
        # Get script content - either directly or from file reference
        script_content = fallback.script
        if not script_content and fallback.script_reference:
            try:
                with open(fallback.script_reference, 'r') as f:
                    script_content = f.read()
                logger.info(f"Loaded script from file: {fallback.script_reference}")
            except Exception as e:
                logger.error(f"Failed to load script from {fallback.script_reference}: {e}")
                return {
                    "success": False,
                    "error": f"Could not load script file: {fallback.script_reference}",
                    "data": None
                }
        
        if not script_content:
            return {
                "success": False,
                "error": "No script content provided (neither script nor script_reference)",
                "data": None
            }
        
        # If function_name is provided, call the function and capture result
        if fallback.function_name:
            script_content += f"\n\n# Execute the function and capture result\nresult = {fallback.function_name}()"
        
        script_result = await self.execute_python_script(script_content, context_data)
        
        # Format results
        body = [
            {
                "key": "question",
                "value": question,
                "description": "The financial question that was analyzed"
            },
            {
                "key": "analysis_method",
                "value": "Python Fallback Analysis",
                "description": "Custom Python script analysis using MCP-gathered data"
            }
        ]
        
        # Add data gathering results
        for i, result in enumerate(data_results):
            if result["success"]:
                body.append({
                    "key": f"data_source_{i+1}",
                    "value": f"{result['tool']} from {result['server']}",
                    "description": f"Successfully gathered data using {result['tool']}"
                })
        
        # Add Python analysis results
        if script_result["success"]:
            body.append({
                "key": "analysis_results",
                "value": script_result["result"],
                "description": "Results from custom Python analysis script"
            })
        else:
            body.append({
                "key": "analysis_error",
                "value": script_result["error"],
                "description": "Error occurred during Python analysis"
            })
        
        return {
            "success": True,
            "data": {
                "description": description,
                "body": body,
                "metadata": {
                    "timestamp": datetime.now().isoformat(),
                    "execution_method": "python_fallback",
                    "data_sources": [r.get("server", "unknown") for r in data_results if r["success"]],
                    "calculation_methods": ["python_script_analysis"],
                    "script_success": script_result["success"]
                }
            }
        }

    async def format_execution_results(
        self, 
        question: str,
        description: str,
        execution_results: List[Dict[str, Any]], 
        successful_calls: int, 
        failed_calls: int
    ) -> Dict[str, Any]:
        """Format execution results into QnA-compatible JSON structure"""
        
        body = [
            {
                "key": "question",
                "value": question,
                "description": "The financial question that was executed"
            },
            {
                "key": "execution_summary",
                "value": f"{successful_calls} successful, {failed_calls} failed",
                "description": "Summary of tool call execution results"
            }
        ]
        
        # Add results from successful tool calls
        for i, result in enumerate(execution_results):
            if result["success"]:
                tool_data = result.get("result", {})
                body.append({
                    "key": f"step_{i+1}_{result['tool']}",
                    "value": tool_data,
                    "description": f"Results from {result['tool']} executed on {result['server']}"
                })
            else:
                body.append({
                    "key": f"step_{i+1}_{result['tool']}_error",
                    "value": result["error"],
                    "description": f"Error executing {result['tool']} on {result['server']}"
                })
        
        return {
            "success": True,
            "data": {
                "description": description,
                "body": body,
                "metadata": {
                    "timestamp": datetime.now().isoformat(),
                    "execution_summary": {
                        "total_steps": len(execution_results),
                        "successful_steps": successful_calls,
                        "failed_steps": failed_calls,
                        "success_rate": f"{(successful_calls/len(execution_results)*100):.1f}%" if execution_results else "0%"
                    },
                    "data_sources": list(set([r.get("server", "unknown") for r in execution_results if r["success"]])),
                    "calculation_methods": ["mcp_tool_execution"],
                    "execution_mode": "live_data"
                }
            }
        }

# Initialize the enhanced execution engine
execution_engine = EnhancedFinancialExecutionEngine()

@app.on_event("startup")
async def startup_event():
    """Initialize the execution engine on startup"""
    await execution_engine.initialize()

@app.post("/execute", response_model=ExecutionResponse)
async def execute_plan(request: ExecutionRequest):
    """
    Execute a tool call plan or Python fallback and return structured financial data
    """
    try:
        logger.info(f"Received execution request for: {request.question}")
        
        # Execute the plan
        result = await execution_engine.execute_plan(request)
        
        return ExecutionResponse(
            success=result["success"],
            data=result.get("data"),
            error=result.get("error"),
            timestamp=datetime.now().isoformat()
        )
        
    except Exception as e:
        logger.error(f"Error in execute endpoint: {e}")
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy", 
        "timestamp": datetime.now().isoformat(),
        "available_tools": len(execution_engine.tool_server_mapping),
        "mcp_servers": list(execution_engine.mcp_servers.keys()),
        "features": ["mcp_tools", "python_fallback"]
    }

@app.get("/tools")
async def list_available_tools():
    """List all available tools and their server mappings"""
    return {
        "tools": execution_engine.tool_server_mapping,
        "servers": execution_engine.mcp_servers,
        "total_tools": len(execution_engine.tool_server_mapping)
    }

if __name__ == "__main__":
    print("Starting Enhanced Financial Analysis Execution Engine...")
    print("Server will be available at: http://localhost:8003")
    print("API Documentation at: http://localhost:8003/docs")
    print("\nEnhancements:")
    print("✅ MCP tool execution")
    print("✅ Python fallback script execution")
    print("✅ Data flow from MCP to Python")
    print("✅ Secure Python sandbox execution")
    
    uvicorn.run(app, host="0.0.0.0", port=8003)