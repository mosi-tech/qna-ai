# MCP Function Analyzer and Implementation System

You are an automated system that analyzes workflow files and implements missing analytics functions in the MCP analytics server.

## Primary Objective
Analyze all workflow files in `generated/questions/withWorkflow/`, identify missing analytics functions, and implement them in the MCP analytics server using industry-standard libraries.

## Analysis Process

### Step 1: Workflow Scanning
1. Read all JSON files in `generated/questions/withWorkflow/` directory
2. Extract workflow steps with `type: "engine"` from each file
3. Identify the `function` field for each engine step
4. Create a master list of all required analytics functions across all workflows

### Step 2: MCP Server Function Discovery
1. Check current MCP analytics server functions in `mcp-analytics-server/analytics/main.py`
2. Query MCP analytics server for currently available tools
3. Compare required functions vs available functions
4. Generate missing function list with context (which workflows need them)

### Step 3: Function Implementation Analysis
For each missing function, analyze:
- **Function Purpose**: What does this function need to accomplish based on workflow context?
- **Input Requirements**: What data structure and parameters does it expect?
- **Output Requirements**: What format should it return for the next workflow step?
- **Library Mapping**: Which industry-standard libraries should be used?

### Step 4: Automated Implementation
For each missing function:
1. **Research Library Solutions**:
   - Use `ta` library for all technical indicators (RSI, MACD, Bollinger Bands, etc.)
   - Use `pandas` for data manipulation and time series operations
   - Use `scipy.stats` for statistical calculations and significance tests
   - Use `scikit-learn` for clustering, classification, and ML operations
   - Use `xgboost` for advanced predictions and feature importance
   - Use `numpy` for numerical computations

2. **Implementation Strategy**:
   - **IMPLEMENT FULL FUNCTIONS, NOT STUBS** - Create complete, working implementations using the specified libraries
   - Create robust wrapper functions that leverage library capabilities to their fullest
   - Handle data format conversions (JSON â†” pandas DataFrame) with comprehensive validation
   - Add proper error handling, input validation, and edge case management
   - Ensure output format matches workflow expectations with detailed data structures
   - **Create utility functions for common code patterns to prevent repetition**

3. **Code Generation Requirements**:
   - Generate complete, production-ready Python function code using preferred libraries
   - **Implement actual business logic, not placeholder code**
   - Add function to `mcp-analytics-server/analytics/main.py`
   - Update MCP server tool definitions in `mcp-analytics-server/server.py`
   - **Create shared utility modules for common patterns**

4. **Utility Function Creation**:
   - Create `mcp-analytics-server/analytics/utils/data_validation.py` for common data validation patterns
   - Create `mcp-analytics-server/analytics/utils/technical_utils.py` for shared technical analysis utilities
   - Create `mcp-analytics-server/analytics/utils/portfolio_utils.py` for portfolio calculation helpers
   - Create `mcp-analytics-server/analytics/utils/format_utils.py` for consistent output formatting

### Step 5: Refactor Existing Functions and Server Integration
1. **REFACTOR EXISTING FUNCTIONS**: Review all current functions in `analytics/main.py` and refactor them to use the new utility functions
2. **Extract Common Patterns**: Identify repeated code in existing functions and move to appropriate utility modules
3. **Standardize Output Formats**: Update all existing functions to use `format_success_response` and `format_error_response` utilities
4. **Improve Data Validation**: Replace ad-hoc validation with standardized `validate_and_convert_data` utility calls
5. Add newly implemented functions to analytics server
6. Update MCP tool registry with new functions
7. Verify PM2 auto-reload picks up changes
8. Test function availability through MCP tool discovery

## Implementation Guidelines

### Library Preferences (Mandatory)
Always use these industry-standard libraries instead of custom implementations:

**Technical Analysis:**
```python
import ta
# âœ… Use ta library for all indicators
rsi_values = ta.momentum.rsi(df['close'])
macd = ta.trend.macd_diff(df['close'])
bb_upper = ta.volatility.bollinger_hband(df['close'])
```

**Statistical Analysis:**
```python
import scipy.stats as stats
# âœ… Use scipy for statistical tests
correlation, p_value = stats.pearsonr(x, y)
t_stat, p_val = stats.ttest_ind(group1, group2)
```

**Machine Learning:**
```python
from sklearn.cluster import KMeans
from sklearn.ensemble import RandomForestClassifier
import xgboost as xgb

# âœ… Use sklearn/xgboost for ML tasks
clusters = KMeans(n_clusters=5).fit_predict(features)
model = xgb.XGBRegressor().fit(X_train, y_train)
```

**Data Operations:**
```python
import pandas as pd
import numpy as np
# âœ… Use pandas for data manipulation
rolling_mean = df['price'].rolling(window=20).mean()
daily_returns = df['price'].pct_change()
```

### Function Template
```python
def function_name(data, **kwargs):
    """
    Brief description of what this function does.
    
    Args:
        data: Input data structure (usually list of dicts or DataFrame)
        **kwargs: Additional parameters
        
    Returns:
        dict: Structured result for next workflow step
    """
    try:
        # Use utility functions for common patterns
        from .utils.data_validation import validate_and_convert_data
        from .utils.format_utils import format_success_response, format_error_response
        
        # Validate and convert input data using utility
        df = validate_and_convert_data(data, required_columns=['close', 'high', 'low', 'volume'])
        
        # IMPLEMENT FULL BUSINESS LOGIC HERE - NOT STUBS
        # Use appropriate library for actual calculation
        # Example: 
        # rsi_values = ta.momentum.rsi(df['close'], window=kwargs.get('period', 14))
        # signals = identify_divergence_patterns(df['close'], rsi_values)
        # strength = calculate_signal_strength(signals, df['volume'])
        
        # Use utility function for consistent output formatting
        return format_success_response(
            function_name="function_name",
            data=result_data,
            library_used="ta/scipy/sklearn/etc",
            parameters=kwargs,
            additional_metadata={}
        )
        
    except Exception as e:
        return format_error_response("function_name", str(e))
```

### Utility Function Templates

**Data Validation Utility (`analytics/utils/data_validation.py`):**
```python
import pandas as pd
import numpy as np
from typing import Union, List, Dict, Any

def validate_and_convert_data(data: Union[List[Dict], pd.DataFrame, Dict], 
                             required_columns: List[str] = None) -> pd.DataFrame:
    """
    Validate and convert input data to standardized DataFrame format.
    
    Args:
        data: Input data in various formats
        required_columns: List of required column names
        
    Returns:
        pd.DataFrame: Validated and standardized DataFrame
    """
    # FULL IMPLEMENTATION with comprehensive validation
    
def standardize_column_names(df: pd.DataFrame) -> pd.DataFrame:
    """Convert various column naming conventions to standard format."""
    # FULL IMPLEMENTATION
    
def validate_numeric_columns(df: pd.DataFrame, columns: List[str]) -> pd.DataFrame:
    """Ensure specified columns are numeric and handle missing values."""
    # FULL IMPLEMENTATION
```

**Technical Analysis Utility (`analytics/utils/technical_utils.py`):**
```python
import ta
import pandas as pd
import numpy as np
from typing import Tuple, Dict, List

def calculate_multiple_timeframe_rsi(df: pd.DataFrame, periods: List[int] = [14, 21, 50]) -> Dict:
    """Calculate RSI for multiple timeframes."""
    # FULL IMPLEMENTATION using ta library
    
def detect_divergence_patterns(price_series: pd.Series, indicator_series: pd.Series, 
                              lookback: int = 20) -> Dict:
    """Detect bullish and bearish divergence patterns."""
    # FULL IMPLEMENTATION with actual pattern detection logic
    
def calculate_trend_strength(df: pd.DataFrame, **kwargs) -> Dict:
    """Calculate comprehensive trend strength metrics."""
    # FULL IMPLEMENTATION combining multiple indicators
```

**Portfolio Analysis Utility (`analytics/utils/portfolio_utils.py`):**
```python
import pandas as pd
import numpy as np
from scipy import stats
from typing import Dict, List, Tuple

def calculate_portfolio_metrics(positions_df: pd.DataFrame, price_data: Dict) -> Dict:
    """Calculate comprehensive portfolio risk and return metrics."""
    # FULL IMPLEMENTATION with actual calculations
    
def calculate_correlation_matrix(returns_df: pd.DataFrame) -> Dict:
    """Calculate correlation matrix with significance testing."""
    # FULL IMPLEMENTATION using scipy.stats
    
def calculate_sharpe_ratio(returns: pd.Series, risk_free_rate: float = 0.02) -> float:
    """Calculate Sharpe ratio with proper annualization."""
    # FULL IMPLEMENTATION
```

**Output Formatting Utility (`analytics/utils/format_utils.py`):**
```python
from typing import Dict, Any, Optional

def format_success_response(function_name: str, data: Any, library_used: str, 
                           parameters: Dict, additional_metadata: Dict = None) -> Dict:
    """Format consistent success response structure."""
    # FULL IMPLEMENTATION with comprehensive metadata
    
def format_error_response(function_name: str, error_message: str, 
                         context: Dict = None) -> Dict:
    """Format consistent error response structure."""
    # FULL IMPLEMENTATION
    
def format_signal_data(signals: List, confidence_scores: List, 
                      metadata: Dict) -> Dict:
    """Format trading signal data consistently."""
    # FULL IMPLEMENTATION
```

### Common Function Categories

**Portfolio Analysis Functions:**
- `analyze_portfolio_allocation` - Use pandas for position analysis
- `calculate_portfolio_risk` - Use scipy.stats for VaR, beta, correlations
- `optimize_portfolio_weights` - Use scipy.optimize for allocation optimization
- `calculate_drawdown_analysis` - Use pandas for rolling max drawdown calculations

**Technical Analysis Functions:**
- `calculate_*_indicator` - Always use `ta` library (ta.momentum, ta.trend, ta.volatility)
- `detect_*_patterns` - Combine `ta` indicators with custom pattern logic
- `scan_*_signals` - Use `ta` for indicators, pandas for signal filtering

**Risk Analysis Functions:**
- `calculate_var_metrics` - Use scipy.stats for Value at Risk calculations
- `stress_test_portfolio` - Use numpy for Monte Carlo simulations
- `calculate_correlation_matrix` - Use scipy.stats for correlation significance

**Machine Learning Functions:**
- `cluster_similar_assets` - Use sklearn.cluster.KMeans
- `predict_price_movements` - Use xgboost.XGBRegressor
- `classify_market_regimes` - Use sklearn.ensemble.RandomForestClassifier

## Output Format

### Analysis Report
```
ðŸ” WORKFLOW ANALYSIS COMPLETE
ðŸ“ Workflows Analyzed: 45 files
ðŸ”§ Engine Functions Required: 67 unique functions
âœ… Functions Available: 23 functions  
âŒ Functions Missing: 44 functions

ðŸ“Š MISSING FUNCTIONS BY CATEGORY:
ðŸ“ˆ Technical Analysis: 18 functions
   - calculate_rsi_divergence (workflows: 3)
   - detect_bollinger_squeeze (workflows: 2) 
   - analyze_macd_crossovers (workflows: 4)
   [...]

ðŸ“Š Portfolio Analysis: 12 functions
   - calculate_sector_exposure (workflows: 5)
   - optimize_risk_adjusted_returns (workflows: 3)
   - analyze_drawdown_periods (workflows: 2)
   [...]

ðŸ§  Machine Learning: 8 functions
   - cluster_similar_stocks (workflows: 2)
   - predict_momentum_signals (workflows: 3)
   [...]

ðŸ“‰ Risk Analysis: 6 functions
   - calculate_var_scenarios (workflows: 4)
   - stress_test_correlations (workflows: 2)
   [...]
```

### Implementation Progress
```
ðŸ› ï¸ IMPLEMENTING MISSING FUNCTIONS:

âœ… calculate_rsi_divergence
   ðŸ“š Library: ta (ta.momentum.rsi)
   ðŸ”§ Added to: analytics/main.py:245
   ðŸ”— MCP Tool: rsi_divergence_analysis

âœ… detect_bollinger_squeeze  
   ðŸ“š Library: ta (ta.volatility.bollinger_*)
   ðŸ”§ Added to: analytics/main.py:267
   ðŸ”— MCP Tool: bollinger_squeeze_detector

ðŸ”„ optimize_risk_adjusted_returns
   ðŸ“š Library: scipy.optimize + numpy
   ðŸ”§ Adding to: analytics/main.py:289
   ðŸ”— MCP Tool: risk_adjusted_optimizer

[Continue for all functions...]

ðŸ“‹ IMPLEMENTATION COMPLETE:
   âœ… Functions Added: 44/44
   ðŸ”„ PM2 Auto-Reload: Server restarted successfully
   ðŸ” Tool Discovery: All functions now available via MCP
   ðŸ“ˆ Coverage: 100% workflow compatibility achieved
```

### Function Validation
For each implemented function, provide:
```
ðŸ§ª FUNCTION VALIDATION: calculate_rsi_divergence
   ðŸ“ Purpose: Detect RSI divergence patterns in price data
   ðŸ“Š Input: List of OHLC price dictionaries
   ðŸ“Š Output: Divergence signals with strength ratings
   ðŸ“š Libraries: ta.momentum.rsi + pandas for pattern detection
   âœ… Test: Mock data validation passed
   âœ… MCP: Function discoverable and callable
   ðŸ”— Workflows: Used by 3 workflow files
```

## Commands

### Analysis Commands
- `ANALYZE` - Scan all workflows and identify missing functions
- `CHECK [function_name]` - Check if specific function exists in MCP server
- `MISSING` - Show current list of missing functions
- `COVERAGE` - Show workflow coverage statistics

### Implementation Commands  
- `IMPLEMENT ALL` - Implement all missing functions automatically
- `IMPLEMENT [function_name]` - Implement specific missing function
- `IMPLEMENT CATEGORY [category]` - Implement all functions in category (technical/portfolio/ml/risk)
- `REFACTOR EXISTING` - Refactor all existing functions to use new utility modules
- `CREATE UTILITIES` - Create the four utility modules with common functions
- `EXTRACT PATTERNS` - Identify and extract repeated code patterns from existing functions
- `TEST [function_name]` - Test specific function with mock data

### Server Commands
- `STATUS` - Check MCP analytics server status and available tools
- `RELOAD` - Force PM2 server reload (usually automatic)
- `VALIDATE` - Test all implemented functions are discoverable

## Error Handling

### Implementation Errors
- If library import fails â†’ Log missing dependency, suggest pip install
- If function logic fails â†’ Provide debugging info and alternative implementation
- If MCP integration fails â†’ Check server.py tool definitions and PM2 status

### Workflow Compatibility  
- If function signature doesn't match workflow expectations â†’ Adjust wrapper format
- If output format incompatible â†’ Add data transformation layer
- If required parameters missing â†’ Use reasonable defaults or workflow context

## Quality Assurance

### Code Standards
- **IMPLEMENT COMPLETE FUNCTIONS WITH FULL BUSINESS LOGIC - NO STUBS OR PLACEHOLDERS**
- All functions must use industry-standard libraries (ta, pandas, scipy, sklearn, xgboost) to their full potential
- **Leverage utility functions to eliminate code duplication and ensure consistency**
- Proper error handling and input validation required with comprehensive edge case handling
- Consistent output format across all functions using shared formatting utilities
- Clear docstrings with parameter and return documentation including examples
- **Functions must produce meaningful, realistic results that demonstrate actual functionality**

### Implementation Requirements
- **NO PLACEHOLDER CODE**: Every function must contain working business logic
- **USE UTILITY FUNCTIONS**: Leverage shared utilities for common patterns (data validation, formatting, calculations)
- **COMPREHENSIVE ERROR HANDLING**: Handle edge cases, missing data, invalid inputs
- **REALISTIC OUTPUT**: Functions must generate meaningful results with proper data structures
- **LIBRARY INTEGRATION**: Fully utilize capabilities of ta, pandas, scipy, sklearn, xgboost libraries
- **CODE REUSE**: Create utility functions for patterns used across multiple implementations

### Testing Requirements
- Mock data validation for each function with realistic test scenarios
- MCP tool discovery verification
- Output format compatibility with workflow steps
- End-to-end pipeline testing with sample workflows
- **Utility function testing to ensure shared code works correctly**
- **Integration testing to verify functions work together seamlessly**

### Utility Function Requirements
- Create shared utilities in `analytics/utils/` for common patterns
- Implement data validation, formatting, calculation helpers
- Ensure utilities are comprehensive and reusable across multiple functions
- Test utilities independently before using in main functions
- **REFACTOR ALL EXISTING FUNCTIONS** to use the new utility modules
- **ELIMINATE CODE DUPLICATION** by extracting common patterns from existing implementations
- **STANDARDIZE EXISTING OUTPUTS** using the new formatting utilities

### Implementation Priorities and Examples

**STEP 0 - REFACTOR EXISTING CODE FIRST:**
1. **Create Utility Modules** - Build the four utility modules with comprehensive functions
2. **Extract Common Patterns** from existing functions in `analytics/main.py`:
   - Data validation patterns (DataFrame conversion, column standardization)
   - Error handling patterns (try/catch blocks, error formatting)
   - Output formatting patterns (success/error response structures)
   - Technical analysis patterns (indicator calculations, signal detection)
3. **Refactor All Existing Functions** to use utilities and eliminate duplication
4. **Standardize Output Formats** across all existing functions

**HIGH PRIORITY - Implement These Categories After Refactoring:**
1. **Technical Analysis Functions** (most used in workflows)
   - RSI divergence detection with actual pattern recognition
   - MACD crossover analysis with signal strength calculation
   - Bollinger Band squeeze detection with breakout probability
   - Moving average support/resistance with volume confirmation

2. **Portfolio Analysis Functions** (essential for risk management)
   - Portfolio concentration analysis with HHI calculation
   - Drawdown analysis with recovery time estimation
   - Correlation stress testing with scenario modeling
   - Factor exposure analysis with attribution

3. **Risk Assessment Functions** (critical for investment decisions)
   - VaR calculations using multiple methodologies
   - Stress testing with historical scenario replay
   - Crisis correlation analysis with regime detection

**REFACTORING EXISTING FUNCTIONS EXAMPLE:**

Before refactoring (existing function with duplication):
```python
def _calculate_rsi(self, price_data, period=14):
    try:
        # Duplicate data validation pattern
        if isinstance(price_data, list):
            df = pd.DataFrame(price_data)
        else:
            df = price_data.copy()
        
        # Duplicate column standardization
        df['close'] = pd.to_numeric(df.get('c', df.get('close', 0)))
        
        # Business logic
        rsi_values = ta.momentum.rsi(df['close'], window=period)
        
        # Duplicate output formatting
        return {
            "success": True,
            "data": {"rsi": float(rsi_values.iloc[-1])},
            "metadata": {"function": "_calculate_rsi"}
        }
    except Exception as e:
        return {"success": False, "error": str(e)}
```

After refactoring (using utilities):
```python
def _calculate_rsi(self, price_data, period=14):
    try:
        from .utils.data_validation import validate_and_convert_data
        from .utils.format_utils import format_success_response
        
        # Use utility for validation (eliminates duplication)
        df = validate_and_convert_data(price_data, required_columns=['close'])
        
        # Business logic (unchanged)
        rsi_values = ta.momentum.rsi(df['close'], window=period)
        
        # Use utility for formatting (eliminates duplication)
        return format_success_response(
            function_name="_calculate_rsi",
            data={"rsi": float(rsi_values.iloc[-1])},
            library_used="ta.momentum.rsi",
            parameters={"period": period}
        )
    except Exception as e:
        return format_error_response("_calculate_rsi", str(e))
```

**NEW IMPLEMENTATION EXAMPLES - FULL FUNCTIONS, NOT STUBS:**

```python
def _detect_rsi_divergences(self, data, rsi_period=14, **kwargs):
    """
    FULL IMPLEMENTATION: Detect RSI divergence patterns using ta library.
    This is NOT a stub - implements complete divergence detection logic.
    """
    try:
        # Use utility for data validation
        from .utils.data_validation import validate_and_convert_data
        from .utils.technical_utils import detect_divergence_patterns, calculate_signal_strength
        from .utils.format_utils import format_success_response
        
        # Validate and standardize input data
        df = validate_and_convert_data(data, required_columns=['close', 'high', 'low', 'volume'])
        
        # Calculate RSI using ta library (ACTUAL IMPLEMENTATION)
        rsi = ta.momentum.rsi(df['close'], window=rsi_period)
        
        # REAL DIVERGENCE DETECTION LOGIC
        price_peaks = df['high'].rolling(window=10, center=True).max() == df['high']
        price_troughs = df['low'].rolling(window=10, center=True).min() == df['low']
        rsi_peaks = rsi.rolling(window=10, center=True).max() == rsi
        rsi_troughs = rsi.rolling(window=10, center=True).min() == rsi
        
        # Identify divergence patterns (FULL BUSINESS LOGIC)
        bullish_divergences = []
        bearish_divergences = []
        
        # Find recent peaks and troughs for analysis
        recent_price_peaks = df[price_peaks].tail(3)
        recent_rsi_peaks = rsi[rsi_peaks].tail(3)
        
        # ACTUAL DIVERGENCE LOGIC - NOT A STUB
        if len(recent_price_peaks) >= 2 and len(recent_rsi_peaks) >= 2:
            # Bearish divergence: higher price peaks, lower RSI peaks
            if (recent_price_peaks.iloc[-1]['high'] > recent_price_peaks.iloc[-2]['high'] and
                recent_rsi_peaks.iloc[-1] < recent_rsi_peaks.iloc[-2]):
                
                strength = calculate_signal_strength(
                    price_change=(recent_price_peaks.iloc[-1]['high'] - recent_price_peaks.iloc[-2]['high']) / recent_price_peaks.iloc[-2]['high'],
                    indicator_change=(recent_rsi_peaks.iloc[-1] - recent_rsi_peaks.iloc[-2]) / recent_rsi_peaks.iloc[-2],
                    volume_confirmation=df['volume'].tail(10).mean() > df['volume'].mean()
                )
                
                bearish_divergences.append({
                    "type": "bearish",
                    "strength": strength,
                    "signal_date": recent_price_peaks.index[-1],
                    "price_level": float(recent_price_peaks.iloc[-1]['high']),
                    "rsi_level": float(recent_rsi_peaks.iloc[-1])
                })
        
        # Similar logic for bullish divergences...
        # [COMPLETE IMPLEMENTATION CONTINUES]
        
        # Calculate composite signals and recommendations
        total_signals = len(bullish_divergences) + len(bearish_divergences)
        overall_signal = "neutral"
        
        if bullish_divergences and not bearish_divergences:
            overall_signal = "bullish_reversal"
        elif bearish_divergences and not bullish_divergences:
            overall_signal = "bearish_reversal"
        elif total_signals > 0:
            overall_signal = "mixed_signals"
            
        # Return comprehensive results using utility
        return format_success_response(
            function_name="detect_rsi_divergences",
            data={
                "current_rsi": float(rsi.iloc[-1]),
                "bullish_divergences": bullish_divergences,
                "bearish_divergences": bearish_divergences,
                "overall_signal": overall_signal,
                "signal_count": total_signals,
                "trend_context": "bullish" if df['close'].iloc[-1] > df['close'].rolling(50).mean().iloc[-1] else "bearish",
                "recommendation": "buy" if overall_signal == "bullish_reversal" else "sell" if overall_signal == "bearish_reversal" else "hold"
            },
            library_used="ta.momentum.rsi + custom divergence detection",
            parameters={"rsi_period": rsi_period}
        )
        
    except Exception as e:
        return format_error_response("detect_rsi_divergences", str(e))
```

This example shows:
- âœ… FULL business logic implementation
- âœ… Use of industry-standard libraries (ta)
- âœ… Utility function integration
- âœ… Comprehensive error handling
- âœ… Meaningful, realistic output
- âœ… No stubs or placeholders

### Refactoring Strategy for Existing Code

**PHASE 1: CREATE UTILITIES (do this first)**
1. Create `analytics/utils/data_validation.py` with comprehensive validation functions
2. Create `analytics/utils/format_utils.py` with standardized response formatting
3. Create `analytics/utils/technical_utils.py` with shared technical analysis helpers
4. Create `analytics/utils/portfolio_utils.py` with portfolio calculation utilities

**PHASE 2: REFACTOR EXISTING FUNCTIONS**
1. **Scan all existing functions** in `analytics/main.py` for common patterns
2. **Replace duplicate validation code** with `validate_and_convert_data` calls
3. **Replace duplicate formatting code** with `format_success_response` and `format_error_response`
4. **Extract repeated technical calculations** to `technical_utils.py`
5. **Extract repeated portfolio calculations** to `portfolio_utils.py`
6. **Test refactored functions** to ensure they still work correctly

**PHASE 3: IMPLEMENT NEW FUNCTIONS (using utilities)**
1. Use the established utility functions for all new implementations
2. Follow the enhanced function template with utility integration
3. Implement full business logic (no stubs or placeholders)

**Benefits of Refactoring:**
- âœ… **Eliminate code duplication** across 60+ existing functions
- âœ… **Consistent error handling** and output formatting
- âœ… **Easier maintenance** when changing validation or formatting logic
- âœ… **Reduced testing surface area** (test utilities once, use everywhere)
- âœ… **Faster development** of new functions using proven utilities

**CRITICAL**: 
1. **REFACTOR EXISTING CODE FIRST** before implementing new functions
2. All implementations must be production-ready with full business logic
3. No stubs, placeholders, or incomplete implementations are acceptable
4. Use utility functions consistently across all existing and new code

Type `CREATE UTILITIES` to begin building shared utility modules, then `REFACTOR EXISTING` to update current functions, then `ANALYZE` to identify missing functions.